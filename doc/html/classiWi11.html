<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OneUp Wi-11 Simulator - Programmer&#39;s Guide: iWi11 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a>  </div>
  <div class="headertitle">
<h1>iWi11 Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="iWi11" -->
<p>Defines the internal logic of the Wi-11.  
<a href="#_details">More...</a></p>

<p><a href="classiWi11-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#ad9b13831ad9a83a8abbc3a77794b38bc">DisplayMemory</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the state of memory to standard out.  <a href="#ad9b13831ad9a83a8abbc3a77794b38bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a143e669e3c7f46c3d1524838c8d74d94">DisplayRegisters</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the state of every register to standard out.  <a href="#a143e669e3c7f46c3d1524838c8d74d94"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#ae502d86eb25fe6e1169e800939362074">ExecuteNext</a> (bool verbose=false)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the instruction pointed to by the PC.  <a href="#ae502d86eb25fe6e1169e800939362074"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a87f8cd9014f7ae2edaa8928257fc84e9">LoadObj</a> (const char *filename)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the object file and sets up memory as it describes.  <a href="#a87f8cd9014f7ae2edaa8928257fc84e9"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a45ebe6e8d33dbc94bfbec0aef22dae6a">_Add</a> (const Decoder_Directory::REGISTER_ID &amp;DR, const Decoder_Directory::REGISTER_ID &amp;SR1, const Decoder_Directory::REGISTER_ID &amp;SR2)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two registers and stores the result in a third.  <a href="#a45ebe6e8d33dbc94bfbec0aef22dae6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#aee7d9647106b62eae74b6eeb29d0ab2d">_Add</a> (const Decoder_Directory::REGISTER_ID &amp;DR, const Decoder_Directory::REGISTER_ID &amp;SR1, const <a class="el" href="classiWord.html">iWord</a> &amp;immediate)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant to a register and stores the result in another.  <a href="#aee7d9647106b62eae74b6eeb29d0ab2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a6d18d19f9f93dcfeded98a13449de64b">_And</a> (const Decoder_Directory::REGISTER_ID &amp;DR, const Decoder_Directory::REGISTER_ID &amp;SR1, const Decoder_Directory::REGISTER_ID &amp;SR2)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-wise ands two registers and stores the result in a third.  <a href="#a6d18d19f9f93dcfeded98a13449de64b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a4344763aa4efa0d384c9228b4b85e205">_And</a> (const Decoder_Directory::REGISTER_ID &amp;DR, const Decoder_Directory::REGISTER_ID &amp;SR1, const <a class="el" href="classiWord.html">iWord</a> &amp;immediate)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-wise ands a register with a constant and stores the result in another register.  <a href="#a4344763aa4efa0d384c9228b4b85e205"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a42d2c50609424634873413d7a6614397">_Branch</a> (const <a class="el" href="classiWord.html">iWord</a> &amp;address)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the last 9 bits of the PC.  <a href="#a42d2c50609424634873413d7a6614397"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#ae510f127a0c3b87d42cdbe5b14204a65">_Debug</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated?  <a href="#ae510f127a0c3b87d42cdbe5b14204a65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classiRegister.html">iRegister</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a00f9ff87c8948464f435f00b10d20dfd">_GetRegister</a> (const Decoder_Directory::REGISTER_ID &amp;id)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a reference to the register corresponding to "id".  <a href="#a00f9ff87c8948464f435f00b10d20dfd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a44e0e3fef9c35401b5a026fb448e872c">_JSR</a> (const <a class="el" href="classiWord.html">iWord</a> &amp;w, bool)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate a jump to a subroutine (alter the PC).  <a href="#a44e0e3fef9c35401b5a026fb448e872c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#ac8fece98ceab4592a5761e6917b5b7a2">_JSRR</a> (const Decoder_Directory::REGISTER_ID &amp;baseR, const <a class="el" href="classiWord.html">iWord</a> &amp;address, bool)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate a jump to a subroutine (alter the PC). param[in] baseR A register whose value acts as a base address.  <a href="#ac8fece98ceab4592a5761e6917b5b7a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a8dac5a6aca2f4c6b398d9a0c44297226">_Load</a> (const Decoder_Directory::REGISTER_ID &amp;DR, const <a class="el" href="classiWord.html">iWord</a> &amp;address)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a word in memory into a register.  <a href="#a8dac5a6aca2f4c6b398d9a0c44297226"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a2a331ba57f78c203ba55fefde42cbc2b">_LoadI</a> (const Decoder_Directory::REGISTER_ID &amp;DR, const <a class="el" href="classiWord.html">iWord</a> &amp;address)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an indirect load.  <a href="#a2a331ba57f78c203ba55fefde42cbc2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a29bb8d1f20ead4f5908c5505a06e5c57">_LoadR</a> (const Decoder_Directory::REGISTER_ID &amp;DR, const Decoder_Directory::REGISTER_ID &amp;baseR, const <a class="el" href="classiWord.html">iWord</a> &amp;address)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a register-relative load.  <a href="#a29bb8d1f20ead4f5908c5505a06e5c57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a8925fab615cdc317ab256d514c23bc5e">_Not</a> (const Decoder_Directory::REGISTER_ID &amp;DR, const Decoder_Directory::REGISTER_ID &amp;SR)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-wise nots a register and stores the result in another.  <a href="#a8925fab615cdc317ab256d514c23bc5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#ae6c1048642dbf2c03c60062f6aaabfd2">_Ret</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return from a subroutine.  <a href="#ae6c1048642dbf2c03c60062f6aaabfd2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a1bd8c4396aa8f3d01b18e14083c25056">_STI</a> (const Decoder_Directory::REGISTER_ID &amp;SR1, const <a class="el" href="classiWord.html">iWord</a> &amp;address)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an indirect store.  <a href="#a1bd8c4396aa8f3d01b18e14083c25056"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#aed4eb93ca7dd50a00dbed816a3ab2e28">_Store</a> (const Decoder_Directory::REGISTER_ID &amp;SR1, const <a class="el" href="classiWord.html">iWord</a> &amp;address)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a register's value into memory at a specified address.  <a href="#aed4eb93ca7dd50a00dbed816a3ab2e28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#aec2d6cb4a20c44ce3f9468964831d39b">_STR</a> (const Decoder_Directory::REGISTER_ID &amp;SR1, const Decoder_Directory::REGISTER_ID &amp;baseR, const <a class="el" href="classiWord.html">iWord</a> &amp;address)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perfroms a register-relative store.  <a href="#aec2d6cb4a20c44ce3f9468964831d39b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a74da9304180f3cbece4b7e87e8a53a5d">_Trap</a> (const <a class="el" href="classiWord.html">iWord</a> &amp;code)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Branches to a trap vector.  <a href="#a74da9304180f3cbece4b7e87e8a53a5d"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Defines the internal logic of the Wi-11. </p>
<dl class="user"><dt><b></b></dt><dd>The methods present in this interface are meant to simulate the Wi-11's fetch-execute loop. Any implementation of this will be expected to house 8 private instances of the <a class="el" href="classRegister.html" title="Implements iRegister.">Register</a> class as general purpose registers and each of these should have an associated REGISTER_ID enum token. A reference to an <a class="el" href="classiMemory.html" title="Defines the functionality of memory in the Wi-11 machine.">iMemory</a> class is also necessary.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The implementers of a super class will also have to incorporate some sort of interaction with a CCR structure. An interface for this interaction is not provided. </dd></dl>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a00f9ff87c8948464f435f00b10d20dfd"></a><!-- doxytag: member="iWi11::_GetRegister" ref="a00f9ff87c8948464f435f00b10d20dfd" args="(const Decoder_Directory::REGISTER_ID &amp;id)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classiRegister.html">iRegister</a>&amp; iWi11::_GetRegister </td>
          <td>(</td>
          <td class="paramtype">const Decoder_Directory::REGISTER_ID &amp;&#160;</td>
          <td class="paramname"> <em>id</em>&#160;)</td>
          <td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a reference to the register corresponding to "id". </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>A REGISTER_ID corresponding to one of the private registers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A reference to the id'd register. </dd></dl>

</div>
</div>
<a class="anchor" id="a45ebe6e8d33dbc94bfbec0aef22dae6a"></a><!-- doxytag: member="iWi11::_Add" ref="a45ebe6e8d33dbc94bfbec0aef22dae6a" args="(const Decoder_Directory::REGISTER_ID &amp;DR, const Decoder_Directory::REGISTER_ID &amp;SR1, const Decoder_Directory::REGISTER_ID &amp;SR2)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_Add </td>
          <td>(</td>
          <td class="paramtype">const Decoder_Directory::REGISTER_ID &amp;&#160;</td>
          <td class="paramname"> <em>DR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Decoder_Directory::REGISTER_ID &amp;&#160;</td>
          <td class="paramname"> <em>SR1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Decoder_Directory::REGISTER_ID &amp;&#160;</td>
          <td class="paramname"> <em>SR2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds two registers and stores the result in a third. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">DR</td><td>The destination register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SR1</td><td>The first source register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SR2</td><td>The second source register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>SR1 and SR2 are not changed. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Updates the CCR. </dd></dl>

</div>
</div>
<a class="anchor" id="aee7d9647106b62eae74b6eeb29d0ab2d"></a><!-- doxytag: member="iWi11::_Add" ref="aee7d9647106b62eae74b6eeb29d0ab2d" args="(const Decoder_Directory::REGISTER_ID &amp;DR, const Decoder_Directory::REGISTER_ID &amp;SR1, const iWord &amp;immediate)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_Add </td>
          <td>(</td>
          <td class="paramtype">const Decoder_Directory::REGISTER_ID &amp;&#160;</td>
          <td class="paramname"> <em>DR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Decoder_Directory::REGISTER_ID &amp;&#160;</td>
          <td class="paramname"> <em>SR1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiWord.html">iWord</a> &amp;&#160;</td>
          <td class="paramname"> <em>immediate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a constant to a register and stores the result in another. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">DR</td><td>The destination register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SR1</td><td>The source register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">immediate</td><td>The immediate value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>SR1 and "immediate" are not changed. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Updates the CCR. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d18d19f9f93dcfeded98a13449de64b"></a><!-- doxytag: member="iWi11::_And" ref="a6d18d19f9f93dcfeded98a13449de64b" args="(const Decoder_Directory::REGISTER_ID &amp;DR, const Decoder_Directory::REGISTER_ID &amp;SR1, const Decoder_Directory::REGISTER_ID &amp;SR2)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_And </td>
          <td>(</td>
          <td class="paramtype">const Decoder_Directory::REGISTER_ID &amp;&#160;</td>
          <td class="paramname"> <em>DR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Decoder_Directory::REGISTER_ID &amp;&#160;</td>
          <td class="paramname"> <em>SR1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Decoder_Directory::REGISTER_ID &amp;&#160;</td>
          <td class="paramname"> <em>SR2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bit-wise ands two registers and stores the result in a third. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">DR</td><td>The destination register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SR1</td><td>The first source register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SR2</td><td>The second source register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>SR1 and SR2 are not changed. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Updates the CCR. </dd></dl>

</div>
</div>
<a class="anchor" id="a4344763aa4efa0d384c9228b4b85e205"></a><!-- doxytag: member="iWi11::_And" ref="a4344763aa4efa0d384c9228b4b85e205" args="(const Decoder_Directory::REGISTER_ID &amp;DR, const Decoder_Directory::REGISTER_ID &amp;SR1, const iWord &amp;immediate)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_And </td>
          <td>(</td>
          <td class="paramtype">const Decoder_Directory::REGISTER_ID &amp;&#160;</td>
          <td class="paramname"> <em>DR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Decoder_Directory::REGISTER_ID &amp;&#160;</td>
          <td class="paramname"> <em>SR1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiWord.html">iWord</a> &amp;&#160;</td>
          <td class="paramname"> <em>immediate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bit-wise ands a register with a constant and stores the result in another register. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">DR</td><td>The destination register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SR1</td><td>The source register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">immediate</td><td>The immediate value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>SR1 and "immediate" are not changed. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Updates the CCR. </dd></dl>

</div>
</div>
<a class="anchor" id="a42d2c50609424634873413d7a6614397"></a><!-- doxytag: member="iWi11::_Branch" ref="a42d2c50609424634873413d7a6614397" args="(const iWord &amp;address)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_Branch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiWord.html">iWord</a> &amp;&#160;</td>
          <td class="paramname"> <em>address</em>&#160;)</td>
          <td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the last 9 bits of the PC. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The 9 bits to become the end of the PC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>"address" is not changed. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ae510f127a0c3b87d42cdbe5b14204a65"></a><!-- doxytag: member="iWi11::_Debug" ref="ae510f127a0c3b87d42cdbe5b14204a65" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_Debug </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deprecated? </p>
<p>Does nothing. </p>

</div>
</div>
<a class="anchor" id="a44e0e3fef9c35401b5a026fb448e872c"></a><!-- doxytag: member="iWi11::_JSR" ref="a44e0e3fef9c35401b5a026fb448e872c" args="(const iWord &amp;w, bool)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_JSR </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiWord.html">iWord</a> &amp;&#160;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initiate a jump to a subroutine (alter the PC). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>A 9 bit offset for the PC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>The PC has "w" as its 9 least significant bits. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If the link bit was set for this instruction, R7 will hold the old value of the PC. However, the CCR will not be altered for this instruction, depite R7 being altered. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8fece98ceab4592a5761e6917b5b7a2"></a><!-- doxytag: member="iWi11::_JSRR" ref="ac8fece98ceab4592a5761e6917b5b7a2" args="(const Decoder_Directory::REGISTER_ID &amp;baseR, const iWord &amp;address, bool)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_JSRR </td>
          <td>(</td>
          <td class="paramtype">const Decoder_Directory::REGISTER_ID &amp;&#160;</td>
          <td class="paramname"> <em>baseR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiWord.html">iWord</a> &amp;&#160;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initiate a jump to a subroutine (alter the PC). param[in] baseR A register whose value acts as a base address. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>A 6 bit offset to the base address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>The PC is the value in baseR plus the value in address. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If the link bit was set for this instruction, R7 will hold the old value of the PC. However, the CCR will not be altered for this instruction, depite R7 being altered. </dd></dl>

</div>
</div>
<a class="anchor" id="a8dac5a6aca2f4c6b398d9a0c44297226"></a><!-- doxytag: member="iWi11::_Load" ref="a8dac5a6aca2f4c6b398d9a0c44297226" args="(const Decoder_Directory::REGISTER_ID &amp;DR, const iWord &amp;address)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_Load </td>
          <td>(</td>
          <td class="paramtype">const Decoder_Directory::REGISTER_ID &amp;&#160;</td>
          <td class="paramname"> <em>DR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiWord.html">iWord</a> &amp;&#160;</td>
          <td class="paramname"> <em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Loads a word in memory into a register. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">DR</td><td>The destination register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>When concatenated with the PC, forms address in memory from which to load. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><a class="el" href="classMemory.html" title="Implements iMemory.">Memory</a> and "address" have not changed. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Updates the CCR. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a331ba57f78c203ba55fefde42cbc2b"></a><!-- doxytag: member="iWi11::_LoadI" ref="a2a331ba57f78c203ba55fefde42cbc2b" args="(const Decoder_Directory::REGISTER_ID &amp;DR, const iWord &amp;address)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_LoadI </td>
          <td>(</td>
          <td class="paramtype">const Decoder_Directory::REGISTER_ID &amp;&#160;</td>
          <td class="paramname"> <em>DR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiWord.html">iWord</a> &amp;&#160;</td>
          <td class="paramname"> <em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs an indirect load. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">DR</td><td>The destination register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>A 9-bit offset to the PC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><a class="el" href="classMemory.html" title="Implements iMemory.">Memory</a> and "address" have not changed. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code.</dd></dl>
<p>Works similar to _Load() but when memory is read, it uses the address found to again access memory. In this indirect way, a load can be made from anywhere in <a class="el" href="classMemory.html" title="Implements iMemory.">Memory</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Updates the CCR. </dd></dl>

</div>
</div>
<a class="anchor" id="a29bb8d1f20ead4f5908c5505a06e5c57"></a><!-- doxytag: member="iWi11::_LoadR" ref="a29bb8d1f20ead4f5908c5505a06e5c57" args="(const Decoder_Directory::REGISTER_ID &amp;DR, const Decoder_Directory::REGISTER_ID &amp;baseR, const iWord &amp;address)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_LoadR </td>
          <td>(</td>
          <td class="paramtype">const Decoder_Directory::REGISTER_ID &amp;&#160;</td>
          <td class="paramname"> <em>DR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Decoder_Directory::REGISTER_ID &amp;&#160;</td>
          <td class="paramname"> <em>baseR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiWord.html">iWord</a> &amp;&#160;</td>
          <td class="paramname"> <em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a register-relative load. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">DR</td><td>The destination register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baseR</td><td>A register whose value works as a base address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>An 6-bit index from the base address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><a class="el" href="classMemory.html" title="Implements iMemory.">Memory</a>, "baseR", and "address" have no changed. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code.</dd></dl>
<p>Loads from "baseR" plus "address".</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Updates the CCR. </dd></dl>

</div>
</div>
<a class="anchor" id="a8925fab615cdc317ab256d514c23bc5e"></a><!-- doxytag: member="iWi11::_Not" ref="a8925fab615cdc317ab256d514c23bc5e" args="(const Decoder_Directory::REGISTER_ID &amp;DR, const Decoder_Directory::REGISTER_ID &amp;SR)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_Not </td>
          <td>(</td>
          <td class="paramtype">const Decoder_Directory::REGISTER_ID &amp;&#160;</td>
          <td class="paramname"> <em>DR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Decoder_Directory::REGISTER_ID &amp;&#160;</td>
          <td class="paramname"> <em>SR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bit-wise nots a register and stores the result in another. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">DR</td><td>The destination register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SR</td><td>The source register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Updates the CCR. </dd></dl>

</div>
</div>
<a class="anchor" id="ae6c1048642dbf2c03c60062f6aaabfd2"></a><!-- doxytag: member="iWi11::_Ret" ref="ae6c1048642dbf2c03c60062f6aaabfd2" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_Ret </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return from a subroutine. </p>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>The PC now holds the value that was (and still is) in R7. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This can be used to jump anywhere in memory. However, this is not the intended usage. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Updates the CCR. </dd></dl>

</div>
</div>
<a class="anchor" id="aed4eb93ca7dd50a00dbed816a3ab2e28"></a><!-- doxytag: member="iWi11::_Store" ref="aed4eb93ca7dd50a00dbed816a3ab2e28" args="(const Decoder_Directory::REGISTER_ID &amp;SR1, const iWord &amp;address)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_Store </td>
          <td>(</td>
          <td class="paramtype">const Decoder_Directory::REGISTER_ID &amp;&#160;</td>
          <td class="paramname"> <em>SR1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiWord.html">iWord</a> &amp;&#160;</td>
          <td class="paramname"> <em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stores a register's value into memory at a specified address. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">SR1</td><td>The source register (holds the data to be stored). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>When concatenated with the PC, forms the address for the store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>SR1 and "address" are not changed. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code. </dd></dl>

</div>
</div>
<a class="anchor" id="a1bd8c4396aa8f3d01b18e14083c25056"></a><!-- doxytag: member="iWi11::_STI" ref="a1bd8c4396aa8f3d01b18e14083c25056" args="(const Decoder_Directory::REGISTER_ID &amp;SR1, const iWord &amp;address)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_STI </td>
          <td>(</td>
          <td class="paramtype">const Decoder_Directory::REGISTER_ID &amp;&#160;</td>
          <td class="paramname"> <em>SR1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiWord.html">iWord</a> &amp;&#160;</td>
          <td class="paramname"> <em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs an indirect store. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">SR1</td><td>The source register (holds the data to be stored). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>A 9-bit offset to the PC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>"SR1" and "address" are not changed. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code.</dd></dl>
<p>Works similar to _Store() but when memory is read, it uses the address found to again access memory. In this indirect way, a store can be made to anywhere in <a class="el" href="classMemory.html" title="Implements iMemory.">Memory</a>. </p>

</div>
</div>
<a class="anchor" id="aec2d6cb4a20c44ce3f9468964831d39b"></a><!-- doxytag: member="iWi11::_STR" ref="aec2d6cb4a20c44ce3f9468964831d39b" args="(const Decoder_Directory::REGISTER_ID &amp;SR1, const Decoder_Directory::REGISTER_ID &amp;baseR, const iWord &amp;address)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_STR </td>
          <td>(</td>
          <td class="paramtype">const Decoder_Directory::REGISTER_ID &amp;&#160;</td>
          <td class="paramname"> <em>SR1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Decoder_Directory::REGISTER_ID &amp;&#160;</td>
          <td class="paramname"> <em>baseR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiWord.html">iWord</a> &amp;&#160;</td>
          <td class="paramname"> <em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perfroms a register-relative store. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">SR1</td><td>The source register (holds the data to be stored). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baseR</td><td>A register whose value acts as a base address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>A 6-bit index from the base address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>SR1, baseR, and "address" are not changed. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code. </dd></dl>

</div>
</div>
<a class="anchor" id="a74da9304180f3cbece4b7e87e8a53a5d"></a><!-- doxytag: member="iWi11::_Trap" ref="a74da9304180f3cbece4b7e87e8a53a5d" args="(const iWord &amp;code)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_Trap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiWord.html">iWord</a> &amp;&#160;</td>
          <td class="paramname"> <em>code</em>&#160;)</td>
          <td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Branches to a trap vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td>The trap code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>"code" is not changed. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The traps are as follows: <ul>
<li>0x21 - OUT - Write the character formed from the eight least significant bits of R0 to standard out. </li>
<li>0x22 - PUTS - Write the a string to standard out starting at the address pointed to by R0 and ending at a null character. </li>
<li>0x23 - IN - Prompt for, and read, a single character from standard in. Re-print it and store its ascii value in R0 (with leading zeros). </li>
<li>0x25 - HALT - End execution and print an appropriate message to standard out. </li>
<li>0x31 - INN - Prompt for, and read, a positive decimal number from standard in. Re-print it and store it in R0 (the number must in 16-bit range). </li>
<li>0x43 - RND - Generate a random number and store it in R0.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Traps 0x23, 0x31, and 0x43 all update the CCR. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Standard in is the keyboard.<br/>
 Stardard out is the console. </dd></dl>

</div>
</div>
<a class="anchor" id="a87f8cd9014f7ae2edaa8928257fc84e9"></a><!-- doxytag: member="iWi11::LoadObj" ref="a87f8cd9014f7ae2edaa8928257fc84e9" args="(const char *filename)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool iWi11::LoadObj </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>filename</em>&#160;)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Loads the object file and sets up memory as it describes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The name of the object file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>"filename" is not changed. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if and only if the load was successful.</dd></dl>
<p>If "false" is returned, prints an appropriate error message to the user.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This fucntion can be called multiple times. Each time the PC is overwritten. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9b13831ad9a83a8abbc3a77794b38bc"></a><!-- doxytag: member="iWi11::DisplayMemory" ref="ad9b13831ad9a83a8abbc3a77794b38bc" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void iWi11::DisplayMemory </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints the state of memory to standard out. </p>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>The calling object is not changed. </dd></dl>

</div>
</div>
<a class="anchor" id="a143e669e3c7f46c3d1524838c8d74d94"></a><!-- doxytag: member="iWi11::DisplayRegisters" ref="a143e669e3c7f46c3d1524838c8d74d94" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void iWi11::DisplayRegisters </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints the state of every register to standard out. </p>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>The calling object is not changed.</dd></dl>
<p>The values of all 8 general purpose registers, the CCR, and PC are all printed. </p>

</div>
</div>
<a class="anchor" id="ae502d86eb25fe6e1169e800939362074"></a><!-- doxytag: member="iWi11::ExecuteNext" ref="ae502d86eb25fe6e1169e800939362074" args="(bool verbose=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool iWi11::ExecuteNext </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>verbose</em> = <code>false</code>&#160;)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Executes the instruction pointed to by the PC. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>If true, machine state information is displayed after each step. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if and only if the end of the program have been reached.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>This function is the brains of the operation, so to speak. Almost the entire fetch-execute loop of the Wi-11 is present here. In particular, this function must interpret the instructions and manage the CCRs. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For a complete list of the instructions, see <a class="el" href="index.html#instructions">Wi-11 Instructions</a>. </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sun Jan 23 2011 18:47:49 for OneUp Wi-11 Simulator - Programmer's Guide by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
