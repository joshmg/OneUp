<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OneUp Wi-11 Simulator: iWi11 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a>  </div>
  <div class="headertitle">
<h1>iWi11 Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="iWi11" -->
<p>Defines the internal logic of the Wi-11.  
<a href="#_details">More...</a></p>
<!-- startSectionHeader --><div class="dynheader">
Inheritance diagram for iWi11:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><!-- endSectionSummary --><!-- startSectionContent --><div class="dyncontent">
<div class="center"><img src="classiWi11__inherit__graph.png" border="0" usemap="#iWi11_inherit__map" alt="Inheritance graph"/></div>
<map name="iWi11_inherit__map" id="iWi11_inherit__map">
<area shape="rect" id="node3" href="classWi11.html" title="Wi11" alt="" coords="7,83,57,112"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center><!-- endSectionContent --></div>

<p><a href="classiWi11-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a379b2619c928a8dde1df28d596440ec0">iWi11</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and organizes the componts of the <a class="el" href="classWi11.html">Wi11</a> machine.  <a href="#a379b2619c928a8dde1df28d596440ec0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a87f8cd9014f7ae2edaa8928257fc84e9">LoadObj</a> (const char *filename)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the object file and sets up memory as it describes.  <a href="#a87f8cd9014f7ae2edaa8928257fc84e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#ad9b13831ad9a83a8abbc3a77794b38bc">DisplayMemory</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the state of memory to standard out.  <a href="#ad9b13831ad9a83a8abbc3a77794b38bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a143e669e3c7f46c3d1524838c8d74d94">DisplayRegisters</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the state of every register to standard out.  <a href="#a143e669e3c7f46c3d1524838c8d74d94"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#ae502d86eb25fe6e1169e800939362074">ExecuteNext</a> (bool verbose=false)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the instruction pointed to by the PC.  <a href="#ae502d86eb25fe6e1169e800939362074"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classiRegister.html">iRegister</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#aa1696b5bb260a94e1fb4a9922369cebf">_GetRegister</a> (const Decoder::REGISTER_ID &amp;id)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a reference to the register corresponding to "id".  <a href="#aa1696b5bb260a94e1fb4a9922369cebf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a65f699c773084a631cd7373cae05b5da">_Add</a> (const Decoder::REGISTER_ID DR, const Decoder::REGISTER_ID SR1, const Decoder::REGISTER_ID SR2)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two registers and stores the result in a third.  <a href="#a65f699c773084a631cd7373cae05b5da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a6345dc089e3a699bd30fc442bd8f6d85">_Add</a> (const Decoder::REGISTER_ID DR, const Decoder::REGISTER_ID SR1, const <a class="el" href="classiWord.html">iWord</a> &amp;immediate)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant to a register and stores the result in another.  <a href="#a6345dc089e3a699bd30fc442bd8f6d85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a90cd8f3daa1788f029cabe198c19efb3">_And</a> (const Decoder::REGISTER_ID DR, const Decoder::REGISTER_ID SR1, const Decoder::REGISTER_ID SR2)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-wise ands two registers and stores the result in a third.  <a href="#a90cd8f3daa1788f029cabe198c19efb3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a4785e197f77fb0861e97e8d18c3be96f">_And</a> (const Decoder::REGISTER_ID DR, const Decoder::REGISTER_ID SR1, const <a class="el" href="classiWord.html">iWord</a> &amp;immediate)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-wise ands a register with a constant and stores the result in another register.  <a href="#a4785e197f77fb0861e97e8d18c3be96f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a42d2c50609424634873413d7a6614397">_Branch</a> (const <a class="el" href="classiWord.html">iWord</a> &amp;address)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the last 9 bits of the PC.  <a href="#a42d2c50609424634873413d7a6614397"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#ae510f127a0c3b87d42cdbe5b14204a65">_Debug</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated?  <a href="#ae510f127a0c3b87d42cdbe5b14204a65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#ace280c40256d3e0c575b08cf6a0d36f5">_JSR</a> (const <a class="el" href="classiWord.html">iWord</a> &amp;w)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate a jump to a subroutine (alter the PC).  <a href="#ace280c40256d3e0c575b08cf6a0d36f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#aeabd561f2728e2345b6a5ae5cdd5b84a">_JSRR</a> (const <a class="el" href="classiWord.html">iWord</a> &amp;baseR, const <a class="el" href="classiWord.html">iWord</a> &amp;address)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate a jump to a subroutine (alter the PC). param[in] baseR A register whose value acts as a base address.  <a href="#aeabd561f2728e2345b6a5ae5cdd5b84a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#aed1f870b129617436434bb6dcee521ce">_Load</a> (const Decoder::REGISTER_ID DR, const <a class="el" href="classiWord.html">iWord</a> &amp;address)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a word in memory into a register.  <a href="#aed1f870b129617436434bb6dcee521ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#ab8f6fc32bfc363f9798c795320c00894">_LoadI</a> (const Decoder::REGISTER_ID DR, const <a class="el" href="classiWord.html">iWord</a> &amp;address)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an indirect load.  <a href="#ab8f6fc32bfc363f9798c795320c00894"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a47fd64cc3629f9239c75fa4fea753c41">_LoadR</a> (const Decoder::REGISTER_ID DR, Decoder::REGISTER_ID baseR, const <a class="el" href="classiWord.html">iWord</a> &amp;address)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a register-relative load.  <a href="#a47fd64cc3629f9239c75fa4fea753c41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a942ecd7956af6ad9c65c976b968d7832">_Not</a> (const Decoder::REGISTER_ID DR, const Decoder::REGISTER_ID SR)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-wise nots a register and stores the result in another.  <a href="#a942ecd7956af6ad9c65c976b968d7832"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#ae6c1048642dbf2c03c60062f6aaabfd2">_Ret</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return from a subroutine.  <a href="#ae6c1048642dbf2c03c60062f6aaabfd2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a52659070aca67bf8fba76f059bc120aa">_Store</a> (const Decoder::REGISTER_ID SR1, const <a class="el" href="classiWord.html">iWord</a> &amp;address)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a register's value into memory at a specified address.  <a href="#a52659070aca67bf8fba76f059bc120aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a3a299e4526c8c9865f529cc10e293a0c">_STI</a> (const Decoder::REGISTER_ID SR1, const <a class="el" href="classiWord.html">iWord</a> &amp;address)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an indirect store.  <a href="#a3a299e4526c8c9865f529cc10e293a0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a5002f010e61f0677feb9f8a116504a0c">_STR</a> (const Decoder::REGISTER_ID SR1, const Decoder::REGISTER_ID baseR, const <a class="el" href="classiWord.html">iWord</a> &amp;address)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perfroms a register-relative store.  <a href="#a5002f010e61f0677feb9f8a116504a0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual Codes::RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiWi11.html#a74da9304180f3cbece4b7e87e8a53a5d">_Trap</a> (const <a class="el" href="classiWord.html">iWord</a> &amp;code)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Branches to a trap vector.  <a href="#a74da9304180f3cbece4b7e87e8a53a5d"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Defines the internal logic of the Wi-11. </p>
<dl class="user"><dt><b></b></dt><dd>The methods present in this interface are meant to simulate the Wi-11's fetch-execute loop. Any implementation of this will be expected to house 8 private instances of the <a class="el" href="classRegister.html">Register</a> class as general purpose registers and each of these should have an associated REGISTER_ID enum token. A reference to an <a class="el" href="classiMemory.html" title="Mimics the functionality of memory in the Wi-11 machine.">iMemory</a> class is also necessary.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The implementers of a super class will also have to incorporate some sort of interaction with a CCR structure. An interface for this interaction is not provided. </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a379b2619c928a8dde1df28d596440ec0"></a><!-- doxytag: member="iWi11::iWi11" ref="a379b2619c928a8dde1df28d596440ec0" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual iWi11::iWi11 </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates and organizes the componts of the <a class="el" href="classWi11.html">Wi11</a> machine. </p>
<p>Initializes the general purpose registers, CCR, and memory. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa1696b5bb260a94e1fb4a9922369cebf"></a><!-- doxytag: member="iWi11::_GetRegister" ref="aa1696b5bb260a94e1fb4a9922369cebf" args="(const Decoder::REGISTER_ID &amp;id)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classiRegister.html">iRegister</a>&amp; iWi11::_GetRegister </td>
          <td>(</td>
          <td class="paramtype">const Decoder::REGISTER_ID &amp;&#160;</td>
          <td class="paramname"> <em>id</em>&#160;)</td>
          <td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a reference to the register corresponding to "id". </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>A REGISTER_ID corresponding to one of the private registers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A reference to the id'd register. </dd></dl>

<p>Implemented in <a class="el" href="classWi11.html#a17b5041499fa55f6b674e4f1ea8ceb59">Wi11</a>.</p>

</div>
</div>
<a class="anchor" id="a65f699c773084a631cd7373cae05b5da"></a><!-- doxytag: member="iWi11::_Add" ref="a65f699c773084a631cd7373cae05b5da" args="(const Decoder::REGISTER_ID DR, const Decoder::REGISTER_ID SR1, const Decoder::REGISTER_ID SR2)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_Add </td>
          <td>(</td>
          <td class="paramtype">const Decoder::REGISTER_ID&#160;</td>
          <td class="paramname"> <em>DR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Decoder::REGISTER_ID&#160;</td>
          <td class="paramname"> <em>SR1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Decoder::REGISTER_ID&#160;</td>
          <td class="paramname"> <em>SR2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds two registers and stores the result in a third. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">DR</td><td>The destination register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SR1</td><td>The first source register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SR2</td><td>The second source register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>SR1 and SR2 are not changed. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Updates the CCR. </dd></dl>

<p>Implemented in <a class="el" href="classWi11.html#a818de966479e749f8592e73b35f5e2f2">Wi11</a>.</p>

</div>
</div>
<a class="anchor" id="a6345dc089e3a699bd30fc442bd8f6d85"></a><!-- doxytag: member="iWi11::_Add" ref="a6345dc089e3a699bd30fc442bd8f6d85" args="(const Decoder::REGISTER_ID DR, const Decoder::REGISTER_ID SR1, const iWord &amp;immediate)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_Add </td>
          <td>(</td>
          <td class="paramtype">const Decoder::REGISTER_ID&#160;</td>
          <td class="paramname"> <em>DR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Decoder::REGISTER_ID&#160;</td>
          <td class="paramname"> <em>SR1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiWord.html">iWord</a> &amp;&#160;</td>
          <td class="paramname"> <em>immediate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a constant to a register and stores the result in another. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">DR</td><td>The destination register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SR1</td><td>The source register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">immediate</td><td>The immediate value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>SR1 and "immediate" are not changed. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Updates the CCR. </dd></dl>

<p>Implemented in <a class="el" href="classWi11.html#ae3b47b19ae611cd4788891a812cc7ba0">Wi11</a>.</p>

</div>
</div>
<a class="anchor" id="a90cd8f3daa1788f029cabe198c19efb3"></a><!-- doxytag: member="iWi11::_And" ref="a90cd8f3daa1788f029cabe198c19efb3" args="(const Decoder::REGISTER_ID DR, const Decoder::REGISTER_ID SR1, const Decoder::REGISTER_ID SR2)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_And </td>
          <td>(</td>
          <td class="paramtype">const Decoder::REGISTER_ID&#160;</td>
          <td class="paramname"> <em>DR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Decoder::REGISTER_ID&#160;</td>
          <td class="paramname"> <em>SR1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Decoder::REGISTER_ID&#160;</td>
          <td class="paramname"> <em>SR2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bit-wise ands two registers and stores the result in a third. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">DR</td><td>The destination register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SR1</td><td>The first source register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SR2</td><td>The second source register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>SR1 and SR2 are not changed. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Updates the CCR. </dd></dl>

<p>Implemented in <a class="el" href="classWi11.html#af1e68e7a15deeb829f1771855e108bc0">Wi11</a>.</p>

</div>
</div>
<a class="anchor" id="a4785e197f77fb0861e97e8d18c3be96f"></a><!-- doxytag: member="iWi11::_And" ref="a4785e197f77fb0861e97e8d18c3be96f" args="(const Decoder::REGISTER_ID DR, const Decoder::REGISTER_ID SR1, const iWord &amp;immediate)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_And </td>
          <td>(</td>
          <td class="paramtype">const Decoder::REGISTER_ID&#160;</td>
          <td class="paramname"> <em>DR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Decoder::REGISTER_ID&#160;</td>
          <td class="paramname"> <em>SR1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiWord.html">iWord</a> &amp;&#160;</td>
          <td class="paramname"> <em>immediate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bit-wise ands a register with a constant and stores the result in another register. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">DR</td><td>The destination register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SR1</td><td>The source register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">immediate</td><td>The immediate value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>SR1 and "immediate" are not changed. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Updates the CCR. </dd></dl>

<p>Implemented in <a class="el" href="classWi11.html#abb98c230c0e384e4d3a3b9f0e3606db4">Wi11</a>.</p>

</div>
</div>
<a class="anchor" id="a42d2c50609424634873413d7a6614397"></a><!-- doxytag: member="iWi11::_Branch" ref="a42d2c50609424634873413d7a6614397" args="(const iWord &amp;address)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_Branch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiWord.html">iWord</a> &amp;&#160;</td>
          <td class="paramname"> <em>address</em>&#160;)</td>
          <td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the last 9 bits of the PC. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The 9 bits to become the end of the PC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>"address" is not changed. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code. </dd></dl>

<p>Implemented in <a class="el" href="classWi11.html#a09edab9ea53d62c93d5d42bfaa77adf5">Wi11</a>.</p>

</div>
</div>
<a class="anchor" id="ae510f127a0c3b87d42cdbe5b14204a65"></a><!-- doxytag: member="iWi11::_Debug" ref="ae510f127a0c3b87d42cdbe5b14204a65" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_Debug </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deprecated? </p>
<p>Does nothing. </p>

<p>Implemented in <a class="el" href="classWi11.html#a08581ef7b0fa3939185ffa516c905d65">Wi11</a>.</p>

</div>
</div>
<a class="anchor" id="ace280c40256d3e0c575b08cf6a0d36f5"></a><!-- doxytag: member="iWi11::_JSR" ref="ace280c40256d3e0c575b08cf6a0d36f5" args="(const iWord &amp;w)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_JSR </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiWord.html">iWord</a> &amp;&#160;</td>
          <td class="paramname"> <em>w</em>&#160;)</td>
          <td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initiate a jump to a subroutine (alter the PC). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>A 9 bit offset for the PC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>The PC has "w" as its 9 least significant bits. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If the link bit was set for this instruction, R7 will hold the old value of the PC. However, the CCR will not be altered for this instruction, depite R7 being altered. </dd></dl>

<p>Implemented in <a class="el" href="classWi11.html#a84b28efa218ee676a4482e38069f5f8b">Wi11</a>.</p>

</div>
</div>
<a class="anchor" id="aeabd561f2728e2345b6a5ae5cdd5b84a"></a><!-- doxytag: member="iWi11::_JSRR" ref="aeabd561f2728e2345b6a5ae5cdd5b84a" args="(const iWord &amp;baseR, const iWord &amp;address)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_JSRR </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiWord.html">iWord</a> &amp;&#160;</td>
          <td class="paramname"> <em>baseR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiWord.html">iWord</a> &amp;&#160;</td>
          <td class="paramname"> <em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initiate a jump to a subroutine (alter the PC). param[in] baseR A register whose value acts as a base address. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>A 6 bit offset to the base address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>The PC is the value in baseR plus the value in address. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If the link bit was set for this instruction, R7 will hold the old value of the PC. However, the CCR will not be altered for this instruction, depite R7 being altered. </dd></dl>

<p>Implemented in <a class="el" href="classWi11.html#a884c75a5dbe753bc316fb2a8faa30e56">Wi11</a>.</p>

</div>
</div>
<a class="anchor" id="aed1f870b129617436434bb6dcee521ce"></a><!-- doxytag: member="iWi11::_Load" ref="aed1f870b129617436434bb6dcee521ce" args="(const Decoder::REGISTER_ID DR, const iWord &amp;address)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_Load </td>
          <td>(</td>
          <td class="paramtype">const Decoder::REGISTER_ID&#160;</td>
          <td class="paramname"> <em>DR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiWord.html">iWord</a> &amp;&#160;</td>
          <td class="paramname"> <em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Loads a word in memory into a register. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">DR</td><td>The destination register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>When concatenated with the PC, forms address in memory from which to load. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><a class="el" href="classMemory.html">Memory</a> and "address" have not changed. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Updates the CCR. </dd></dl>

<p>Implemented in <a class="el" href="classWi11.html#a521c4d4d670b8bb1e1e7e9226ec2f259">Wi11</a>.</p>

</div>
</div>
<a class="anchor" id="ab8f6fc32bfc363f9798c795320c00894"></a><!-- doxytag: member="iWi11::_LoadI" ref="ab8f6fc32bfc363f9798c795320c00894" args="(const Decoder::REGISTER_ID DR, const iWord &amp;address)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_LoadI </td>
          <td>(</td>
          <td class="paramtype">const Decoder::REGISTER_ID&#160;</td>
          <td class="paramname"> <em>DR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiWord.html">iWord</a> &amp;&#160;</td>
          <td class="paramname"> <em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs an indirect load. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">DR</td><td>The destination register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>A 9-bit offset to the PC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><a class="el" href="classMemory.html">Memory</a> and "address" have not changed. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code.</dd></dl>
<p>Works similar to _Load() but when memory is read, it uses the address found to again access memory. In this indirect way, a load can be made from anywhere in <a class="el" href="classMemory.html">Memory</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Updates the CCR. </dd></dl>

<p>Implemented in <a class="el" href="classWi11.html#a76e05be82843d69572d1b3c9a84f4eb0">Wi11</a>.</p>

</div>
</div>
<a class="anchor" id="a47fd64cc3629f9239c75fa4fea753c41"></a><!-- doxytag: member="iWi11::_LoadR" ref="a47fd64cc3629f9239c75fa4fea753c41" args="(const Decoder::REGISTER_ID DR, Decoder::REGISTER_ID baseR, const iWord &amp;address)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_LoadR </td>
          <td>(</td>
          <td class="paramtype">const Decoder::REGISTER_ID&#160;</td>
          <td class="paramname"> <em>DR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Decoder::REGISTER_ID&#160;</td>
          <td class="paramname"> <em>baseR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiWord.html">iWord</a> &amp;&#160;</td>
          <td class="paramname"> <em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a register-relative load. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">DR</td><td>The destination register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baseR</td><td>A register whose value works as a base address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>An 6-bit index from the base address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><a class="el" href="classMemory.html">Memory</a>, "baseR", and "address" have no changed. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code.</dd></dl>
<p>Loads from "baseR" plus "address".</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Updates the CCR. </dd></dl>

<p>Implemented in <a class="el" href="classWi11.html#a58c642a908084d7629c93e702558e05a">Wi11</a>.</p>

</div>
</div>
<a class="anchor" id="a942ecd7956af6ad9c65c976b968d7832"></a><!-- doxytag: member="iWi11::_Not" ref="a942ecd7956af6ad9c65c976b968d7832" args="(const Decoder::REGISTER_ID DR, const Decoder::REGISTER_ID SR)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_Not </td>
          <td>(</td>
          <td class="paramtype">const Decoder::REGISTER_ID&#160;</td>
          <td class="paramname"> <em>DR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Decoder::REGISTER_ID&#160;</td>
          <td class="paramname"> <em>SR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bit-wise nots a register and stores the result in another. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">DR</td><td>The destination register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SR</td><td>The source register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Updates the CCR. </dd></dl>

<p>Implemented in <a class="el" href="classWi11.html#a13742e76d8e61aa08696459f5bdcaddb">Wi11</a>.</p>

</div>
</div>
<a class="anchor" id="ae6c1048642dbf2c03c60062f6aaabfd2"></a><!-- doxytag: member="iWi11::_Ret" ref="ae6c1048642dbf2c03c60062f6aaabfd2" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_Ret </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return from a subroutine. </p>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>The PC now holds the value that was (and still is) in R7. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This can be used to jump anywhere in memory. However, this is not the intended usage. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Updates the CCR. </dd></dl>

<p>Implemented in <a class="el" href="classWi11.html#ad49e98e49ec62664b3684d63568545f0">Wi11</a>.</p>

</div>
</div>
<a class="anchor" id="a52659070aca67bf8fba76f059bc120aa"></a><!-- doxytag: member="iWi11::_Store" ref="a52659070aca67bf8fba76f059bc120aa" args="(const Decoder::REGISTER_ID SR1, const iWord &amp;address)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_Store </td>
          <td>(</td>
          <td class="paramtype">const Decoder::REGISTER_ID&#160;</td>
          <td class="paramname"> <em>SR1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiWord.html">iWord</a> &amp;&#160;</td>
          <td class="paramname"> <em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stores a register's value into memory at a specified address. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">SR1</td><td>The source register (holds the data to be stored). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>When concatenated with the PC, forms the address for the store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>SR1 and "address" are not changed. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code. </dd></dl>

<p>Implemented in <a class="el" href="classWi11.html#a35746dfc067eedf054ade3c6aeb13eca">Wi11</a>.</p>

</div>
</div>
<a class="anchor" id="a3a299e4526c8c9865f529cc10e293a0c"></a><!-- doxytag: member="iWi11::_STI" ref="a3a299e4526c8c9865f529cc10e293a0c" args="(const Decoder::REGISTER_ID SR1, const iWord &amp;address)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_STI </td>
          <td>(</td>
          <td class="paramtype">const Decoder::REGISTER_ID&#160;</td>
          <td class="paramname"> <em>SR1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiWord.html">iWord</a> &amp;&#160;</td>
          <td class="paramname"> <em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs an indirect store. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">SR1</td><td>The source register (holds the data to be stored). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>A 9-bit offset to the PC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>"SR1" and "address" are not changed. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code.</dd></dl>
<p>Works similar to _Store() but when memory is read, it uses the address found to again access memory. In this indirect way, a store can be made to anywhere in <a class="el" href="classMemory.html">Memory</a>. </p>

<p>Implemented in <a class="el" href="classWi11.html#a7b360f2afbe98cd267941d0a8c584260">Wi11</a>.</p>

</div>
</div>
<a class="anchor" id="a5002f010e61f0677feb9f8a116504a0c"></a><!-- doxytag: member="iWi11::_STR" ref="a5002f010e61f0677feb9f8a116504a0c" args="(const Decoder::REGISTER_ID SR1, const Decoder::REGISTER_ID baseR, const iWord &amp;address)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_STR </td>
          <td>(</td>
          <td class="paramtype">const Decoder::REGISTER_ID&#160;</td>
          <td class="paramname"> <em>SR1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Decoder::REGISTER_ID&#160;</td>
          <td class="paramname"> <em>baseR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiWord.html">iWord</a> &amp;&#160;</td>
          <td class="paramname"> <em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perfroms a register-relative store. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">SR1</td><td>The source register (holds the data to be stored). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baseR</td><td>A register whose value acts as a base address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>A 6-bit index from the base address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>SR1, baseR, and "address" are not changed. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code. </dd></dl>

<p>Implemented in <a class="el" href="classWi11.html#a43d17c3207c05f5519336ff9c2974b2d">Wi11</a>.</p>

</div>
</div>
<a class="anchor" id="a74da9304180f3cbece4b7e87e8a53a5d"></a><!-- doxytag: member="iWi11::_Trap" ref="a74da9304180f3cbece4b7e87e8a53a5d" args="(const iWord &amp;code)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Codes::RESULT iWi11::_Trap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiWord.html">iWord</a> &amp;&#160;</td>
          <td class="paramname"> <em>code</em>&#160;)</td>
          <td><code> [private, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Branches to a trap vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td>The trap code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>"code" is not changed. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SUCCESS or, if something went wrong, an appropriate error code.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The traps are as follows: <ul>
<li>0x21 - OUT - Write the character formed from the eight least significant bits of R0 to standard out. </li>
<li>0x22 - PUTS - Write the a string to standard out starting at the address pointed to by R0 and ending at a null character. </li>
<li>0x23 - IN - Prompt for, and read, a single character from standard in. Re-print it and store its ascii value in R0 (with leading zeros). </li>
<li>0x25 - HALT - End execution and print an appropriate message to standard out. </li>
<li>0x31 - INN - Prompt for, and read, a positive decimal number from standard in. Re-print it and store it in R0 (the number must in 16-bit range). </li>
<li>0x43 - RND - Generate a random number and store it in R0.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Traps 0x23, 0x31, and 0x43 all update the CCR. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Standard in is the keyboard.<br/>
 Stardard out is the console. </dd></dl>

<p>Implemented in <a class="el" href="classWi11.html#af981c1237ba25082ecd7aee3820d19e3">Wi11</a>.</p>

</div>
</div>
<a class="anchor" id="a87f8cd9014f7ae2edaa8928257fc84e9"></a><!-- doxytag: member="iWi11::LoadObj" ref="a87f8cd9014f7ae2edaa8928257fc84e9" args="(const char *filename)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool iWi11::LoadObj </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>filename</em>&#160;)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Loads the object file and sets up memory as it describes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The name of the object file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>"filename" is not changed. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if and only if the load was successful.</dd></dl>
<p>If "false" is returned, prints an appropriate error message to the user.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This fucntion can be called multiple times. Each time the PC is overwritten. </dd></dl>

<p>Implemented in <a class="el" href="classWi11.html#a1bd83a38f0ae1ff1436c98e73ff8b421">Wi11</a>.</p>

</div>
</div>
<a class="anchor" id="ad9b13831ad9a83a8abbc3a77794b38bc"></a><!-- doxytag: member="iWi11::DisplayMemory" ref="ad9b13831ad9a83a8abbc3a77794b38bc" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void iWi11::DisplayMemory </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints the state of memory to standard out. </p>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>The calling object is not changed. </dd></dl>

<p>Implemented in <a class="el" href="classWi11.html#a0f532cefdebd3c33ddc93e8bce4dc06b">Wi11</a>.</p>

</div>
</div>
<a class="anchor" id="a143e669e3c7f46c3d1524838c8d74d94"></a><!-- doxytag: member="iWi11::DisplayRegisters" ref="a143e669e3c7f46c3d1524838c8d74d94" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void iWi11::DisplayRegisters </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints the state of every register to standard out. </p>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>The calling object is not changed.</dd></dl>
<p>The values of all 8 general purpose registers, the CCR, and PC are all printed. </p>

<p>Implemented in <a class="el" href="classWi11.html#a201359b2506539dda72075b908076492">Wi11</a>.</p>

</div>
</div>
<a class="anchor" id="ae502d86eb25fe6e1169e800939362074"></a><!-- doxytag: member="iWi11::ExecuteNext" ref="ae502d86eb25fe6e1169e800939362074" args="(bool verbose=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool iWi11::ExecuteNext </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>verbose</em> = <code>false</code>&#160;)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Executes the instruction pointed to by the PC. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>If true, machine state information is displayed after each step. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if and only if the end of the program have been reached.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>This function is the brains of the operation, so to speak. Almost the entire fetch-execute loop of the Wi-11 is present here. In particular, this function must interpret the instructions and manage the CCRs. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For a complete list of the instructions, see <a class="el" href="index.html#instructions">Wi-11 Instructions</a>. </dd></dl>

<p>Implemented in <a class="el" href="classWi11.html#ace44826e4f92aabd233b68bdd9437c1b">Wi11</a>.</p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sat Jan 22 2011 02:04:03 for OneUp Wi-11 Simulator by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
